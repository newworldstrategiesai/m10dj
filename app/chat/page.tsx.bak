'use client';

import { useState, useCallback, useEffect, useRef, useMemo, Fragment } from 'react';
import { v4 as uuidv4 } from 'uuid';
import dayjs from 'dayjs';
import {
  IconArrowLeft,
  IconDotsVertical,
  IconEdit,
  IconMessages,
  IconPaperclip,
  IconPhotoPlus,
  IconPlus,
  IconSearch,
  IconSend,
  IconVideo,
  IconRobot,
  IconUser,
  IconTrash,
  IconRefresh,
  IconEraser,
  IconDatabase,
  IconPhone,
  IconMenu2,
  IconX,
  IconMessagePlus,
  IconCheck,
  IconChecks
} from '@tabler/icons-react';
import { cn } from '@/lib/utils';
import { Separator } from '@/components/ui/separator';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { ScrollArea } from "@/components/ui/scroll-area";
import { Textarea } from "@/components/ui/textarea";
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { useToast } from '@/components/ui/use-toast';
import { Switch } from "@/components/ui/switch";
import { Label } from "@/components/ui/label";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover"
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from "@/components/ui/dropdown-menu";
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogTrigger } from '@/components/ui/dialog';
import { Badge } from '@/components/ui/badge';
// Import the MessageDetailsModal component
import { MessageDetailsModal } from './components/MessageDetailsModal';
import { TypingIndicator } from './components/TypingIndicator';

// Import initial conversations
import { conversations } from '@/data/conversations.json';

// Import our new components
import { SMSThreadItem } from './components/SMSThreadItem';
import { ChatHeader } from './components/ChatHeader';
import TwilioSetupGuide from '@/components/TwilioSetupGuide';
import NewMessageModal from '@/components/NewMessageModal';
import { createClientComponentClient } from '@supabase/auth-helpers-nextjs';
import { useUser } from '@/hooks/useUser';
import { RealtimeChannel } from '@supabase/supabase-js';
import axios from 'axios';
// Add import for NewSMSDialog at the top of imports
import NewSMSDialog from './components/NewSMSDialog';

// Types
interface Message {
  sender: string;
  message: string;
  timestamp: string;
  to?: string;
  source?: 'twilio_api' | 'supabase' | 'pending' | 'error';
  direction?: 'inbound' | 'outbound';
  timestampMs?: number;
  id?: string; // Add id field for tracking messages
}

interface AIAgent {
  id: string;
  profile: string;
  username: string;
  fullName: string;
  title: string;
  messages: Message[];
  isAI: true;
}

interface SMSContact {
  id: string;
  name: string;
  phone: string;
  lastMessage?: string;
  lastMessageTime?: string;
  destinationNumber?: string; // Add destination number field
}

// Add this interface for SMS users
interface SMSUser {
  id: string;
  profile: string;
  username: string;
  fullName: string;
  title: string;
  messages: Message[];
  phone: string;
  isSMS: true;
  destinationNumber?: string; // Add destination number field
}

// Base conversation type from the imported conversations
interface BaseConversation {
  id: string;
  profile: string;
  username: string;
  fullName: string;
  title: string;
  messages: Message[];
}

// Update the ChatUser type to include SMSUser and ensure all types have the required properties
type ChatUser = BaseConversation & {
  phone?: string;
  isSMS?: boolean;
  destinationNumber?: string;
} | AIAgent | SMSUser;

type Convo = ChatUser['messages'][number];

// Update the handleSelectContact function to work with Supabase contacts
interface Contact {
  id: string;
  first_name: string;
  last_name: string;
  phone: string;
  user_id: string;
  lead_status?: string;
  lead_source?: string;
  opt_in_status?: boolean;
  notes?: string;
  vertical?: string;
  sub_category?: string;
  preferred_language?: string;
}

// Add types for SMS history
interface SMSHistoryMessage {
  id: string;
  sender: 'user' | 'contact';
  message: string;
  timestamp: string;
}

interface SMSHistoryConversation {
  id: string;
  phone: string;
  messages: SMSHistoryMessage[];
  lastMessageTime: number | null;
  lastMessage?: string;
  contact: Contact | null;
  name: string;
}

interface SMSNotification {
  id: string;
  user_id: string;
  from_phone: string;
  message: string;
  contact_name: string;
  contact_id: string | null;
  created_at: string;
}

// Add these type definitions after the existing interfaces
interface ProcessedMessage {
  sender: string;
  message: string;
  timestamp: string;
  timestampMs?: number;
  to?: string;
  source: 'twilio_api' | 'supabase';
  direction: 'inbound' | 'outbound';
}

interface ThreadAutomationSettings {
  responseStyle: 'formal' | 'casual' | 'very-casual';
  messageLength: 'short' | 'medium' | 'long';
}

// Add this interface for the selected message
interface SelectedMessage {
  from: string;
  to: string;
  body: string;
  dateSent: string;
  direction: 'inbound' | 'outbound';
}

// Add new type to track read status
interface ReadStatusMap {
  [threadId: string]: {
    lastReadTimestamp: string;
  };
}

// Add this type guard function at the top of the file
function hasPhone(user: ChatUser): user is (BaseConversation | SMSUser) & { phone: string } {
  return 'phone' in user && typeof user.phone === 'string';
}

// Add these environment variable checks at the top of the file, after imports
const NEXT_PUBLIC_SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL;
const NEXT_PUBLIC_SUPABASE_ANON_KEY = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;
const OPENAI_API_KEY = process.env.OPENAI_API_KEY;

if (!NEXT_PUBLIC_SUPABASE_URL || !NEXT_PUBLIC_SUPABASE_ANON_KEY) {
  console.error('Missing required environment variables for Supabase configuration');
}

// Move normalizePhoneNumber outside the component
function normalizePhoneNumber(phoneNumber?: string): string {
  if (!phoneNumber) return '';
  return phoneNumber.replace(/\D/g, '');
}

function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: NodeJS.Timeout | null = null;
  
  return function(...args: Parameters<T>) {
    if (timeout) clearTimeout(timeout);
    timeout = setTimeout(() => func(...args), wait);
  };
}

// Add these interfaces at the top with other interfaces
interface TwilioMessage {
  direction: 'inbound' | 'outbound';
  from: string;
  body: string;
  dateSent: string | number;
  source?: 'twilio_api' | 'supabase';
  to?: string;
}

interface TwilioApiKeys {
  user_id: string;
  twilio_sid: string;
  twilio_auth_token: string;
}

// Add this helper function near the top of the file with other utility functions
function formatTimestamp(timestamp: string | number): string {
  // If it's a Unix timestamp (number or numeric string)
  if (!isNaN(Number(timestamp))) {
    // Convert to milliseconds if needed (check if seconds vs milliseconds)
    const timestampMs = String(timestamp).length > 10 ? 
      Number(timestamp) : 
      Number(timestamp) * 1000;
    return new Date(timestampMs).toISOString();
  }
  
  // If it's already a valid ISO string, return it as is
  const date = new Date(timestamp);
  if (!isNaN(date.getTime())) {
    return String(timestamp);
  }
  
  // If we get here, the timestamp is invalid
  console.warn('Invalid timestamp:', timestamp);
  return new Date().toISOString();
}

interface ProcessedMessageWithMs extends ProcessedMessage {
  timestampMs: number;
}

interface MessageWithMs extends Message {
  timestampMs: number;
}

export default function ChatPage() {
  const { toast } = useToast();
  const [search, setSearch] = useState('');
  const [debouncedSearch, setDebouncedSearch] = useState('');
  const [threads, setThreads] = useState<ChatUser[]>([]);
  const [selectedUser, setSelectedUser] = useState<ChatUser>(conversations[0]);
  const [mobileSelectedUser, setMobileSelectedUser] = useState<ChatUser | null>(null);
  const [inputMessage, setInputMessage] = useState('');
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [conversationContext, setConversationContext] = useState<Array<{
    role: 'system' | 'user' | 'assistant';
    content: string;
  }>>([]); 
  
  // Add new state variables for AI suggestions
  const [aiSuggestion, setAiSuggestion] = useState<string>('');
  const [isGeneratingSuggestion, setIsGeneratingSuggestion] = useState(false);
  const [showSuggestionPopover, setShowSuggestionPopover] = useState(false);
  
  const chatContainerRef = useRef<HTMLDivElement>(null);
  const [smsContacts, setSMSContacts] = useState<SMSContact[]>([]);
  const [newContactName, setNewContactName] = useState('');
  const [newContactPhone, setNewContactPhone] = useState('');
  const [newMessageModalOpen, setNewMessageModalOpen] = useState(false);
  const [smsError, setSMSError] = useState<string | null>(null);
  const { user } = useUser();
  const userId = user?.id;
  const supabase = createClientComponentClient();
  const [isLoadingSMSHistory, setIsLoadingSMSHistory] = useState(false);
  const [lastFetchTime, setLastFetchTime] = useState<Date | null>(null);
  const [mobileOpen, setMobileOpen] = useState(false);
  const [showTwilioSetupGuide, setShowTwilioSetupGuide] = useState(false);
  const [twilioErrorType, setTwilioErrorType] = useState<'credentials' | 'phone_number' | 'general'>('general');
  const [isAnimating, setIsAnimating] = useState(false);
  const [showDetailsPanel, setShowDetailsPanel] = useState(window.innerWidth >= 768);
  const [showMobileDetailsPanel, setShowMobileDetailsPanel] = useState(false);
  // Add state for the selected message and modal visibility
  const [selectedMessage, setSelectedMessage] = useState<SelectedMessage | null>(null);
  // Add a state for Twilio numbers
  const [userTwilioNumbers, setUserTwilioNumbers] = useState<string[]>([]);
  // Add new state for automation mode
  const [automationMode, setAutomationMode] = useState<'semi' | 'full'>(() => {
    if (typeof window !== 'undefined') {
      return localStorage.getItem('automationMode') as 'semi' | 'full' || 'semi';
    }
    return 'semi';
  });
  const [isAutomationEnabled, setIsAutomationEnabled] = useState(() => {
    if (typeof window !== 'undefined') {
      return localStorage.getItem('isAutomationEnabled') === 'true';
    }
    return false;
  });
  // Add new state variables for automation parameters
  const [responseDelay, setResponseDelay] = useState<'none' | 'short' | 'medium' | 'long'>(() => {
    if (typeof window !== 'undefined') {
      return localStorage.getItem('responseDelay') as 'none' | 'short' | 'medium' | 'long' || 'short';
    }
    return 'short';
  });
  const [responseStyle, setResponseStyle] = useState<'formal' | 'casual' | 'very-casual'>(() => {
    if (typeof window !== 'undefined') {
      return localStorage.getItem('responseStyle') as 'formal' | 'casual' | 'very-casual' || 'casual';
    }
    return 'casual';
  });
  const [messageLength, setMessageLength] = useState<'short' | 'medium' | 'long'>(() => {
    if (typeof window !== 'undefined') {
      return localStorage.getItem('messageLength') as 'short' | 'medium' | 'long' || 'medium';
    }
    return 'medium';
  });
  // Add new state variables for automation status
  const [automationStatus, setAutomationStatus] = useState<'idle' | 'detecting' | 'thinking' | 'sending'>('idle');
  const [automationStatusMessage, setAutomationStatusMessage] = useState<string>('');
  // Add new state variables for countdown
  const [countdownSeconds, setCountdownSeconds] = useState<number | null>(null);
  const [isCancelled, setIsCancelled] = useState(false);
  const countdownRef = useRef<NodeJS.Timeout | null>(null);

  // Add new state for default automation settings
  const [defaultAutomationSettings] = useState({
    isEnabled: true,
    mode: 'full' as 'semi' | 'full',
    responseDelay: 'short' as 'none' | 'short' | 'medium' | 'long',
    responseStyle: 'casual' as 'formal' | 'casual' | 'very-casual',
    messageLength: 'medium' as 'short' | 'medium' | 'long'
  });

  // Add new state for editing contact info
  const [isEditingContact, setIsEditingContact] = useState(false);
  const [editedContact, setEditedContact] = useState<Contact | null>(null);

  // Add new state for Twilio credentials
  const [twilioCredentials, setTwilioCredentials] = useState<{
    twilioSid: string;
    twilioAuthToken: string;
    twilioNumbers: string[];
  } | null>(null);

  // Add new function to fetch Twilio credentials
  const fetchTwilioCredentials = async () => {
    if (!user) return;
    
    try {
      // Get the most recent API key
      const { data: apiKeys, error: apiKeyError } = await supabase
        .from('api_keys')
        .select('*')
        .eq('user_id', user.id)
        .order('created_at', { ascending: false })
        .limit(1);

      if (apiKeyError) {
        console.error('Error fetching API keys:', apiKeyError);
        throw new Error('Failed to fetch Twilio credentials from Supabase');
      }

      const apiKey = apiKeys?.[0];
      if (!apiKey?.twilio_sid || !apiKey?.twilio_auth_token) {
        console.error('No Twilio credentials found in Supabase');
        throw new Error('No Twilio credentials found in Supabase');
      }

      // Fetch Twilio numbers
      const response = await fetch('/api/get-twilio-numbers', {
        headers: {
          'twilioSid': apiKey.twilio_sid,
          'twilioAuthToken': apiKey.twilio_auth_token,
          'userId': user.id
        }
      });

      if (!response.ok) {
        throw new Error('Failed to fetch Twilio numbers');
      }

      const { numbers } = await response.json();

      setTwilioCredentials({
        twilioSid: apiKey.twilio_sid,
        twilioAuthToken: apiKey.twilio_auth_token,
        twilioNumbers: numbers || []
      });
    } catch (error) {
      console.error('Error fetching Twilio credentials from Supabase:', error);
      console.log('Attempting to use environment variables as backup');
      
      try {
        // Make a request to get Twilio numbers using environment variables
        const backupResponse = await fetch('/api/get-twilio-numbers-env', {
          headers: {
            'userId': user.id
          }
        });
        
        if (!backupResponse.ok) {
          throw new Error('Failed to fetch Twilio numbers with environment variables');
        }
        
        const { numbers, twilioSid, twilioAuthToken } = await backupResponse.json();
        
        if (twilioSid && twilioAuthToken) {
          console.log('Using environment variables for Twilio credentials as backup');
          setTwilioCredentials({
            twilioSid,
            twilioAuthToken,
            twilioNumbers: numbers || []
          });
        } else {
          console.error('No valid Twilio credentials available');
        }
      } catch (backupError) {
        console.error('Error using backup credentials:', backupError);
        
        // As a last resort, try to fetch just the Twilio phone number from env
        try {
          const envPhoneResponse = await fetch('/api/get-env-phone-number');
          if (envPhoneResponse.ok) {
            const { phoneNumber } = await envPhoneResponse.json();
            if (phoneNumber) {
              console.log('Retrieved Twilio phone number from environment:', phoneNumber);
              setTwilioCredentials(prev => ({
                twilioSid: prev?.twilioSid || '',
                twilioAuthToken: prev?.twilioAuthToken || '',
                twilioNumbers: [phoneNumber]
              }));
            }
          }
        } catch (phoneError) {
          console.error('Error fetching env phone number:', phoneError);
        }
      }
    }
  };

  // Add useEffect to fetch credentials once
  useEffect(() => {
    if (user && !twilioCredentials) {
      fetchTwilioCredentials();
    }
  }, [user]); // Only run when user changes

  // Use a useEffect to debounce the search
  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedSearch(search);
    }, 300);

    return () => {
      clearTimeout(timer);
    };
  }, [search]);

  // Load threads from localStorage if they exist
  useEffect(() => {
    console.log('Loading initial threads');
    const storedThreads = localStorage.getItem('threads');
    
    const loadThreads = async () => {
      let initialThreads: ChatUser[] = [];
      
      if (storedThreads) {
        console.log('Found stored threads in localStorage');
        const parsedThreads = JSON.parse(storedThreads);
        console.log('Parsed threads:', {
          totalThreads: parsedThreads.length,
          smsThreads: parsedThreads.filter((t: any) => 'isSMS' in t && t.isSMS).length
        });
        initialThreads = parsedThreads;
      } else {
        console.log('No stored threads found, initializing with default AI conversations');
        initialThreads = conversations.filter(convo => !('isSMS' in convo));
      }
      
      setThreads(initialThreads);
      setSelectedUser(initialThreads[0] || conversations[0]); // Fallback to default
      
      // Set a flag to indicate we've completed the initial load
      setLastFetchTime(new Date());
    };
    
    loadThreads();
  }, []); // Remove user dependency to prevent reloading on user changes
  
  // Add a separate effect to fetch SMS history once after initial load
  // with a 5-minute refresh interval
  useEffect(() => {
    if (!user || !lastFetchTime) return;
    
    // Only fetch once on initial load and then on a timer
    const fetchSMSData = async () => {
      try {
        console.log('Scheduled SMS history fetch');
        await fetchSMSHistory();
        // Update the last fetch time
        setLastFetchTime(new Date());
      } catch (error) {
        console.error('Error in scheduled SMS history fetch:', error);
      }
    };
    
    // Fetch SMS data initially
    fetchSMSData();
    
    // Set up a timer to refresh SMS data every 5 minutes
    const refreshInterval = setInterval(fetchSMSData, 5 * 60 * 1000);
    
    // Clean up the interval when the component unmounts
    return () => clearInterval(refreshInterval);
  }, [user, lastFetchTime === null]); // Only refetch when user changes or on first load

  // Save threads to localStorage whenever they are updated
  useEffect(() => {
    if (threads.length > 0) {
      localStorage.setItem('threads', JSON.stringify(threads));
    }
  }, [threads]);

  // Update the useEffect for scrolling to ensure it scrolls to the bottom when new messages are added
  useEffect(() => {
    if (chatContainerRef.current) {
      chatContainerRef.current.scrollTop = chatContainerRef.current.scrollHeight;
    }
  }, [selectedUser.messages]);

  // Add a new useEffect to handle scrolling when the selected user changes
  useEffect(() => {
    const scrollToBottom = () => {
      if (chatContainerRef.current) {
        const scrollContainer = chatContainerRef.current.querySelector('[data-radix-scroll-area-viewport]');
        if (scrollContainer) {
          scrollContainer.scrollTop = scrollContainer.scrollHeight;
        }
      }
    };
    
    // Add a small delay to ensure the DOM has updated
    const timer = setTimeout(() => {
      scrollToBottom();
    }, 100);
    
    return () => clearTimeout(timer);
  }, [selectedUser.id, selectedUser.messages]); // Run when selected user or their messages change

  // Load SMS contacts from localStorage and check Supabase for contact names
  useEffect(() => {
    const loadSMSContacts = async () => {
      if (!user) {
        console.log('No user found, skipping SMS contacts load');
        return;
      }

      try {
        console.log('Loading SMS contacts for user:', user.id);
        // Fetch contacts from Supabase
        const { data: contactsData, error: contactsError } = await supabase
          .from('contacts')
          .select('id, first_name, last_name, phone')
          .eq('user_id', user.id);
            
        if (contactsError) {
          console.error('Error fetching contacts:', contactsError);
          return;
        }

        console.log('Fetched contacts:', contactsData?.length || 0);

        // Update threads with contact names
        if (contactsData) {
          setThreads(prev => {
            const updatedThreads = prev.map(thread => {
              if ('isSMS' in thread && thread.isSMS && thread.phone) {
                const normalizedThreadPhone = normalizePhoneNumber(thread.phone);
                const contact = contactsData.find(c => 
                  normalizePhoneNumber(c.phone) === normalizedThreadPhone
                );
                
                if (contact) {
                  const fullName = `${contact.first_name || ''} ${contact.last_name || ''}`.trim();
                  if (fullName) {
                    return {
                      ...thread,
                      fullName,
                      username: fullName.split(' ')[0]
                    };
                  }
                }
              }
              return thread;
            });
            console.log('Updated threads with contact names:', {
              totalThreads: updatedThreads.length,
              smsThreads: updatedThreads.filter(t => 'isSMS' in t && t.isSMS).length
            });
            return updatedThreads;
          });
        }
      } catch (error) {
        console.error('Error updating contact names:', error);
      }
    };
    
    loadSMSContacts();
  }, [user, supabase]); // Remove normalizePhoneNumber from dependencies

  // Handle search input change with debounce
  const handleSearchChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    // Only update search if we're not currently loading SMS history
    // This prevents the search from triggering unnecessary API calls
    setSearch(e.target.value);
  }, []);

  // Add the processSMSHistory function before the fetchSMSHistory function
  const processSMSHistory = (messages: any[], specificPhoneNumber?: string) => {
    if (specificPhoneNumber) {
      // Update specific thread
      setThreads(prevThreads => {
        const updatedThreads = prevThreads.map(thread => {
          if ('isSMS' in thread && thread.isSMS && normalizePhoneNumber(thread.phone) === normalizePhoneNumber(specificPhoneNumber)) {
            // Map the messages from the SMS logs format to our thread format
            const threadMessages = messages.map((msg: any) => ({
              sender: msg.direction === 'inbound' ? msg.from : 'You',
              message: msg.body,
              timestamp: msg.dateSent || msg.dateCreated,
              source: msg.source || 'twilio_api',
              direction: msg.direction,
              to: msg.to,
              from: msg.from
            }));
            
            return {
              ...thread,
              messages: threadMessages
            };
          }
          return thread;
        });
        console.log('Updated threads for specific phone number:', {
          threadCount: updatedThreads.length,
          phoneNumber: specificPhoneNumber
        });
        return updatedThreads;
      });
    } else {
      // Update all SMS threads
      const messagesByPhone = messages.reduce((acc: any, msg: any) => {
        const phoneKey = msg.direction === 'inbound' ? msg.from : msg.to;
        if (!acc[phoneKey]) {
          acc[phoneKey] = [];
        }
        acc[phoneKey].push({
          sender: msg.direction === 'inbound' ? msg.from : 'You',
          message: msg.body,
          timestamp: msg.dateSent || msg.dateCreated,
          source: msg.source || 'twilio_api',
          direction: msg.direction,
          to: msg.to,
          from: msg.from
        });
        return acc;
      }, {});

      console.log('Grouped messages by phone:', Object.keys(messagesByPhone).length);

      setThreads(prevThreads => {
        const updatedThreads = prevThreads.map(thread => {
          if ('isSMS' in thread && thread.isSMS && thread.phone) {
            const normalizedPhone = normalizePhoneNumber(thread.phone);
            const threadMessages = messagesByPhone[normalizedPhone] || [];
            if (threadMessages.length > 0) {
              return {
                ...thread,
                messages: threadMessages
              };
            }
          }
          return thread;
        });
        console.log('Updated all SMS threads:', {
          threadCount: updatedThreads.length,
          smsThreadCount: updatedThreads.filter(t => 'isSMS' in t && t.isSMS).length
        });
        return updatedThreads;
      });
    }
  };

  // Add a function to create SMS threads from Twilio messages
  const createSMSThreadsFromTwilioMessages = (messages: any[]) => {
    console.log('Creating SMS threads from Twilio messages:', messages.length);
    if (!messages || messages.length === 0) return;
    
    // Get the actual Twilio phone number being used
    // This phone number needs to be extracted from the messages
    let actualTwilioNumber = '';
    
    // Find the first outbound message to see which Twilio number is being used
    const outboundMessage = messages.find(msg => msg.direction === 'outbound');
    if (outboundMessage) {
      actualTwilioNumber = outboundMessage.from;
      console.log('Detected actual Twilio number from outbound message:', actualTwilioNumber);
    } else {
      // If no outbound message, look at the 'to' of an inbound message
      const inboundMessage = messages.find(msg => msg.direction === 'inbound');
      if (inboundMessage) {
        actualTwilioNumber = inboundMessage.to;
        console.log('Detected actual Twilio number from inbound message:', actualTwilioNumber);
      }
    }
    
    // If we found a Twilio number, update the twilioCredentials if it's different
    if (actualTwilioNumber && 
        (!twilioCredentials?.twilioNumbers.includes(actualTwilioNumber))) {
      console.log('Updating Twilio credentials with actual number:', actualTwilioNumber);
      setTwilioCredentials(prev => {
        if (!prev) return {
          twilioSid: '',
          twilioAuthToken: '',
          twilioNumbers: [actualTwilioNumber]
        };
        
        return {
          ...prev,
          twilioNumbers: [actualTwilioNumber, ...prev.twilioNumbers.filter(n => n !== actualTwilioNumber)]
        };
      });
    }
    
    // Group messages by phone number
    const threadsByPhone: Record<string, {messages: any[], latestTimestamp: Date}> = {};
    
    messages.forEach(msg => {
      // For outbound messages, the recipient is the contact
      // For inbound messages, the sender is the contact
      const contactPhone = msg.direction === 'inbound' ? msg.from : msg.to;
      const twilioPhone = msg.direction === 'inbound' ? msg.to : msg.from;
      
      if (!contactPhone) return; // Skip if we can't determine the contact
      
      // Initialize this thread if it doesn't exist
      if (!threadsByPhone[contactPhone]) {
        threadsByPhone[contactPhone] = {
          messages: [],
          latestTimestamp: new Date(0)
        };
      }
      
      // Add the message to this phone's thread
      threadsByPhone[contactPhone].messages.push({
        sender: msg.direction === 'inbound' ? contactPhone : 'You',
        message: msg.body,
        timestamp: msg.dateSent,
        to: msg.to,
        from: msg.from,
        source: msg.source || 'twilio_api',
        direction: msg.direction
      });
      
      // Update the latest timestamp
      const msgDate = new Date(msg.dateSent);
      if (msgDate > threadsByPhone[contactPhone].latestTimestamp) {
        threadsByPhone[contactPhone].latestTimestamp = msgDate;
      }
    });
    
    // Convert to array and sort by latest message
    const newThreads = Object.entries(threadsByPhone)
      .map(([phone, data]) => {
        // Sort messages by timestamp (oldest first)
        const sortedMessages = data.messages.sort((a, b) => 
          new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
        );
        
        // Look for a contact name
        const fullName = phone;
        
        // Get the correct Twilio phone number from the messages
        const destinationNumber = sortedMessages.length > 0
          ? (sortedMessages[0].direction === 'inbound' 
             ? sortedMessages[0].to 
             : sortedMessages[0].from)
          : actualTwilioNumber || (twilioCredentials?.twilioNumbers[0] || '');
        
        return {
          id: `sms-${phone}`,
          profile: '/placeholders/contact-placeholder.png',
          username: fullName.split(' ')[0],
          fullName,
          title: 'SMS Contact',
          messages: sortedMessages,
          phone,
          isSMS: true as const,
          destinationNumber
        };
      })
      .sort((a, b) => {
        // Sort by most recent message
        const aLatest = a.messages.length > 0 ? new Date(a.messages[a.messages.length - 1].timestamp).getTime() : 0;
        const bLatest = b.messages.length > 0 ? new Date(b.messages[b.messages.length - 1].timestamp).getTime() : 0;
        return bLatest - aLatest;
      });
      
    console.log('Created SMS threads:', newThreads.length);
    
    // Update the thread state - carefully merge with existing threads to prevent constant state updates
    setThreads(prevThreads => {
      // Don't update if the threads are effectively the same to prevent re-renders
      // Get existing SMS threads
      const existingSMSThreads = prevThreads.filter(thread => 'isSMS' in thread && thread.isSMS);
      
      // Check if we already have these exact threads with same message counts
      const hasChanges = newThreads.some(newThread => {
        const existingThread = existingSMSThreads.find(t => t.id === newThread.id);
        // If thread doesn't exist or message count is different, we have changes
        return !existingThread || existingThread.messages.length !== newThread.messages.length;
      });
      
      // If no actual changes, return the existing threads to prevent re-render
      if (!hasChanges && existingSMSThreads.length === newThreads.length) {
        console.log('No changes in SMS threads, skipping update');
        return prevThreads;
      }
      
      // Keep all AI agent conversations
      const aiThreads = prevThreads.filter(thread => !('isSMS' in thread) || !thread.isSMS);
      
      // Merge existing SMS threads with new ones
      const mergedThreads = [
        ...aiThreads,
        ...newThreads
      ];
      
      // If this is our first time loading and we have SMS threads,
      // select the most recent SMS thread instead of the default AI thread
      if (newThreads.length > 0 && prevThreads.every(t => !('isSMS' in t) || !t.isSMS)) {
        setSelectedUser(newThreads[0]);
      }
      
      return mergedThreads;
    });
  };
  
  // Update the fetchSMSHistory function to use the thread creation logic
  const fetchSMSHistory = async (phoneNumber?: string) => {
    if (!user) {
      console.log('No user found, skipping SMS history fetch');
      return;
    }
    
    // Prevent duplicate requests for the same data
    if (isLoadingSMSHistory) {
      console.log('Already loading SMS history, skipping duplicate request');
      return;
    }
    
    try {
      setIsLoadingSMSHistory(true);
      console.log('Fetching SMS history for user:', user.id, 'specific phone:', phoneNumber || 'none');
      
      // Build query parameters
      const queryParams = new URLSearchParams();
      if (phoneNumber) {
        queryParams.append('phoneNumber', phoneNumber.replace(/\D/g, ''));
      }
      queryParams.append('page', '1');
      queryParams.append('pageSize', '100');
      queryParams.append('userId', user.id);
      queryParams.append('useEnvVarsAsBackup', 'true');
      
      // Add a cache-busting timestamp to prevent browser caching
      queryParams.append('_t', Date.now().toString());
      
      // Make the API request
      const response = await fetch(`/api/get-sms-logs?${queryParams.toString()}`);
      
      if (!response.ok) {
        throw new Error(`Failed to fetch SMS history: ${response.status} ${response.statusText}`);
      }
      
      const data = await response.json();
      console.log('Fetched SMS history:', {
        totalCount: data.messages?.length || 0,
        phoneNumber: phoneNumber || 'all'
      });
      
      // Create SMS threads from messages if there are any
      if (data.messages && data.messages.length > 0) {
        // If looking for a specific number, use processSMSHistory, otherwise create new threads
        if (phoneNumber) {
          processSMSHistory(data.messages, phoneNumber);
        } else {
          createSMSThreadsFromTwilioMessages(data.messages);
        }
      } else {
        console.log('No SMS messages found');
      }
    } catch (error) {
      console.error('Error fetching SMS history:', error);
      
      // Show Twilio setup guide if needed
      if (error instanceof Error && 
          (error.message.includes('No Twilio credentials') || 
           error.message.includes('Invalid Twilio credentials') ||
           error.message.includes('Failed to fetch Twilio'))) {
        setShowTwilioSetupGuide(true);
        setTwilioErrorType('credentials');
      }
    } finally {
      setIsLoadingSMSHistory(false);
    }
  };

  // Add the sendMessage function
  const sendMessage = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!inputMessage.trim() || !selectedUser) return;
    
    // Add type guard for SMS users
    if (!('isSMS' in selectedUser) || !selectedUser.isSMS || !selectedUser.phone) {
      console.error('Cannot send SMS: Not an SMS user or missing phone number');
      return;
    }

    // Store the message to send
    const messageToSend = inputMessage;
    
    // Generate a temporary ID for this message to track it
    const tempMessageId = `temp_${Date.now()}`;
    
    // Add the message to the current thread immediately for better UX, but mark as pending
    setThreads(prev => {
      return prev.map(thread => {
        if (thread.id === selectedUser.id) {
          // Add the new message to this thread
          const newMessage = {
            sender: 'You',
            message: messageToSend,
            timestamp: new Date().toISOString(),
            direction: 'outbound' as const,
            to: selectedUser.phone,
            from: selectedUser.destinationNumber || (twilioCredentials?.twilioNumbers?.[0] || ''),
            source: 'pending' as any, // Mark as pending initially
            id: tempMessageId // Add temporary ID to identify this message later
          };
          
          return {
            ...thread,
            messages: [...thread.messages, newMessage]
          };
        }
        return thread;
      });
    });
    
    // Clear input message immediately for better UX
    setInputMessage('');
    
    setIsLoading(true);

    try {
      // Prepare the message data
      const messageData = {
        to: selectedUser.phone,
        message: messageToSend,
        threadId: selectedUser.id,
        useEnvVars: !twilioCredentials, // Use env vars if no credentials in state
        from: selectedUser.destinationNumber || (twilioCredentials?.twilioNumbers?.[0] || '')
      };

      console.log('Sending SMS with data:', {
        to: messageData.to,
        messageLength: messageData.message.length,
        from: messageData.from || 'using env vars',
        threadId: messageData.threadId
      });

      // Use the updated endpoint and format
      const response = await fetch('/api/sms/send', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(messageData)
      });

      if (!response.ok) {
        const errorData = await response.json();
        console.error('SMS send error response:', errorData);
        
        // Provide more helpful error messages based on the error type
        if (errorData.error === 'Failed to fetch Twilio credentials') {
          throw new Error('Twilio credentials not found. Please check your environment variables or add credentials in your account settings.');
        } else if (errorData.error === 'No Twilio number configured') {
          throw new Error('No Twilio phone number configured. Please add a phone number in your account settings.');
        } else {
          throw new Error(errorData.error || 'Failed to send SMS');
        }
      }

      const data = await response.json();
      console.log('SMS sent successfully:', data);
      
      // Update the message to show it was sent successfully
      setThreads(prev => {
        return prev.map(thread => {
          if (thread.id === selectedUser.id) {
            // Find and update the temporary message
            const updatedMessages = thread.messages.map(msg => {
              if ((msg as any).id === tempMessageId) {
                return {
                  ...msg,
                  source: 'supabase' as const, // Mark as sent
                  timestamp: new Date().toISOString(), // Update timestamp to server time
                };
              }
              return msg;
            });
            
            return {
              ...thread,
              messages: updatedMessages
            };
          }
          return thread;
        });
      });

      toast({
        title: "SMS sent",
        description: `Message sent to ${selectedUser.fullName}`
      });
      
      // Refresh the SMS history after sending a message to get server confirmation
      setTimeout(() => {
        fetchSMSHistory(selectedUser.phone);
      }, 1000);
    } catch (error: any) {
      console.error('Error sending message:', error);
      setSMSError(error.message || 'Failed to send SMS');
      
      // Update the message to show it failed to send
      setThreads(prev => {
        return prev.map(thread => {
          if (thread.id === selectedUser.id) {
            // Find and update the temporary message
            const updatedMessages = thread.messages.map(msg => {
              if ((msg as any).id === tempMessageId) {
                return {
                  ...msg,
                  source: 'error' as any, // Mark as error
                };
              }
              return msg;
            });
            
            return {
              ...thread,
              messages: updatedMessages
            };
          }
          return thread;
        });
      });
      
      toast({
        title: "Error",
        description: error.message || "Failed to send SMS",
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  };

  // Update the fetchContactInfo function
  const fetchContactInfo = async (phone?: string): Promise<{ name: string; phone: string } | null> => {
    if (!phone) return null;
    
    try {
      const normalizedPhone = normalizePhoneNumber(phone);
      const { data } = await supabase
        .from('contacts')
        .select('first_name, last_name, phone')
        .eq('user_id', user?.id)
        .filter('phone', 'ilike', `%${normalizedPhone}%`)
        .maybeSingle();
      
      if (data) {
        return {
          name: `${data.first_name || ''} ${data.last_name || ''}`.trim(),
          phone: data.phone
        };
      }
      
      return null;
    } catch (error) {
      console.error('Error fetching contact info:', error);
      return null;
    }
  };
  
  // Update the handleSelectUser function with proper typing
  const handleSelectUser = useCallback(async (user: ChatUser, clearSearch = false, event?: React.MouseEvent<HTMLButtonElement>) => {
    // Prevent default behavior if event is provided
    if (event) {
      event.preventDefault();
      event.stopPropagation();
    }
    
    // Start animation
    setIsAnimating(true);
    
    // Set a timeout to allow the animation to complete before updating state
    setTimeout(() => {
      setSelectedUser(user);
      setMobileSelectedUser(user);
      setMobileOpen(false);
      if (clearSearch) setSearch('');
      
      // Set details panel to true if on desktop
      if (window.innerWidth >= 768) {
        setShowDetailsPanel(true);
      }
      
      // Reset animation state
      setIsAnimating(false);
    }, 300); // Match this with the CSS transition duration
    
    // If this is an SMS user, try to fetch contact info
    if ('isSMS' in user && user.isSMS && 'phone' in user) {
      const contactInfo = await fetchContactInfo(user.phone);
      
      if (contactInfo) {
        // Update the user with the contact name
        setSelectedUser(prev => ({
          ...prev,
          fullName: contactInfo.name,
          username: contactInfo.name.split(' ')[0]
        }));
        
        // Also update the thread in the threads list
      setThreads(prev => {
          return prev.map(thread => {
            if (thread.id === user.id) {
            return {
                ...thread,
                fullName: contactInfo.name,
                username: contactInfo.name.split(' ')[0]
              };
            }
            return thread;
          });
        });
      }
      
      // Always fetch the latest messages when selecting an SMS contact
      // Use a small timeout to ensure the UI updates first
      setTimeout(() => {
        if ('phone' in user) {
          // Use a function reference instead of directly calling fetchSMSHistory
          const fetchMessages = () => {
            if (user && 'phone' in user) {
              fetchSMSHistory(user.phone);
            }
          };
          fetchMessages();
        }
      }, 400); // Slightly longer timeout to ensure animation completes
    }
  }, [fetchContactInfo, setThreads, setSelectedUser, setMobileSelectedUser, setMobileOpen, setSearch, setShowDetailsPanel, fetchSMSHistory]);
  
  // Handle back button click with animation
  const handleBackButtonClick = useCallback((e?: React.MouseEvent<HTMLButtonElement>) => {
    // Prevent default behavior if event is provided
    if (e) {
      e.preventDefault();
      e.stopPropagation();
    }
    
    // Start animation
    setIsAnimating(true);
    
    // Set a timeout to allow the animation to complete before updating state
    setTimeout(() => {
      setMobileOpen(true);
      setMobileSelectedUser(null);
      
      // Reset animation state
      setIsAnimating(false);
    }, 300); // Match this with the CSS transition duration
  }, []);

  // Handle selecting an existing contact
  const handleSelectExistingContact = useCallback(async (contact: Contact) => {
    if (!user) {
      console.log('No user found, cannot select contact');
      return;
    }
    
    console.log('Selected existing contact:', {
      contactId: contact.id,
      name: `${contact.first_name} ${contact.last_name}`,
      phone: contact.phone
    });
    
    // Check if there's already a thread for this contact
    const existingThread = threads.find(thread => 
      hasPhone(thread) && 
      thread.phone === contact.phone
    );
    
    if (existingThread) {
      console.log('Found existing thread for phone number:', {
        threadId: existingThread.id,
        phone: hasPhone(existingThread) ? existingThread.phone : 'Not SMS'
      });
      
      // Select the existing thread
      setSelectedUser(existingThread);
      setNewMessageModalOpen(false);
      
      toast({
        title: 'Conversation Opened',
        description: `Showing existing conversation with ${contact.first_name} ${contact.last_name}`,
      });
      
      return;
    }
    
    // Create a new SMS thread for this contact
    const contactName = `${contact.first_name || ''} ${contact.last_name || ''}`.trim() || 'Unknown';
    const contactPhone = contact.phone;
    
    // Create a new SMS thread
    const newThread: SMSUser = {
      id: `sms_${Date.now()}`,
      profile: '/images/default-avatar.png',
      username: contactName,
      fullName: contactName,
      title: 'SMS',
      messages: [],
      phone: contactPhone,
      isSMS: true as const,
      destinationNumber: twilioCredentials?.twilioNumbers[0] || undefined // Use first Twilio number if available
    };
    
    console.log('Created new SMS thread:', {
      threadId: newThread.id,
      phone: newThread.phone,
      destinationNumber: newThread.destinationNumber
    });
    
    // Add the thread to the list
    setThreads(prev => {
      const updatedThreads = [newThread, ...prev];
      console.log('Updated threads with new SMS thread:', {
        totalThreads: updatedThreads.length,
        smsThreads: updatedThreads.filter(t => 'isSMS' in t && t.isSMS).length
      });
      return updatedThreads;
    });
    
    // Start animation
    setIsAnimating(true);
    
    // Set a timeout to allow the animation to complete before updating state
    setTimeout(() => {
      // Select the new thread
      setSelectedUser(newThread);
      setMobileSelectedUser(newThread);
      
      // Close the mobile sidebar if open
      setMobileOpen(false);
      
      // Reset animation state
      setIsAnimating(false);
    }, 300); // Match this with the CSS transition duration
    
    // Fetch the latest messages for this contact
    setTimeout(() => {
      console.log('Fetching messages for new contact:', contactPhone);
      fetchSMSHistory(contactPhone);
    }, 400); // Slightly longer timeout to ensure animation completes
    
    toast({
      title: 'Conversation Started',
      description: `You can now send messages to ${contactName}`,
    });
  }, [user, threads, setThreads, setSelectedUser, setMobileSelectedUser, setMobileOpen, toast, twilioCredentials, fetchSMSHistory]);

  // Create new AI thread
  const createNewThread = useCallback(() => {
    setConversationContext([]); // Reset context for new thread
    const newAgent: AIAgent = {
      id: uuidv4(),
      profile: "/ai-avatar.png",
      username: "AI",
      fullName: "AI Assistant",
      title: "GPT-4 Turbo Powered",
      isAI: true,
      messages: [{
        sender: "AI",
        message: "Hello! I'm your AI assistant powered by GPT-4. How can I help you today?",
        timestamp: new Date().toISOString()
      }]
    };

    setThreads(prev => {
      const updatedThreads = [newAgent, ...prev];
      localStorage.setItem('threads', JSON.stringify(updatedThreads));
      return updatedThreads;
    });
    
    // Start animation
    setIsAnimating(true);
    
    // Set a timeout to allow the animation to complete before updating state
    setTimeout(() => {
      setSelectedUser(newAgent);
      setMobileSelectedUser(newAgent);
      setMobileOpen(false);
      
      // Reset animation state
      setIsAnimating(false);
    }, 300); // Match this with the CSS transition duration
    
        toast({
      title: "New AI chat created",
      description: "Start chatting with your AI assistant",
    });
  }, [toast]);

  // Filter threads based on search - use a memoized version to prevent unnecessary recalculations
  const filteredChatList = useMemo(() => {
    return threads.filter(({ fullName }) =>
      fullName.toLowerCase().includes(search.trim().toLowerCase())
    );
  }, [threads, search]);

  // Update the currentMessage grouping with proper types
  const currentMessage = useMemo(() => {
    // First, ensure all messages have properly formatted timestamps
    const normalizedMessages = selectedUser.messages.map(msg => {
      // Preserve original timestamp for DB messages
      const timestamp = msg.source === 'supabase' ? msg.timestamp : formatTimestamp(msg.timestamp);
      return {
        ...msg,
        timestamp,
        timestampMs: new Date(timestamp).getTime()
      };
    });

    // Sort messages by timestamp
    const sortedMessages = [...normalizedMessages]
      .sort((a, b) => a.timestampMs - b.timestampMs)
      .map(({ timestampMs, ...msg }) => msg);

    // Group by date
    return sortedMessages.reduce(
      (acc: Record<string, Message[]>, message: Message) => {
        const key = dayjs(message.timestamp).format('D MMM, YYYY');
        if (!acc[key]) {
          acc[key] = [];
        }
        acc[key].push(message);
        return acc;
      },
      {}
    );
  }, [selectedUser.messages]);

  // Listen for the custom event to open the add contact modal
  useEffect(() => {
    const handleOpenAddContactModal = () => {
      setNewMessageModalOpen(true);
    };

    window.addEventListener('openAddContactModal', handleOpenAddContactModal);

    return () => {
      window.removeEventListener('openAddContactModal', handleOpenAddContactModal);
    };
  }, []);

  // Add an effect to scroll to bottom when selected user changes
  useEffect(() => {
    if (chatContainerRef.current) {
      chatContainerRef.current.scrollTop = chatContainerRef.current.scrollHeight;
    }
  }, [selectedUser.id]);

  // Add this before the return statement
  console.log('Current user:', user);
  console.log('User ID being passed to NewMessageModal:', user?.id);

  // Add helper function to get delay in milliseconds
  const getDelayDuration = (delay: 'none' | 'short' | 'medium' | 'long'): number => {
    switch (delay) {
      case 'none': return 0;
      case 'short': return 2000; // 2 seconds
      case 'medium': return 5000; // 5 seconds
      case 'long': return 10000; // 10 seconds
      default: return 2000;
    }
  };

  // Add function to handle automatic responses
  const handleAutomaticResponse = useCallback(async (incomingMessage: Message, threadId: string) => {
    const threadSettings = getThreadAutomationSettings(threadId);
    if (!threadSettings.isEnabled || threadSettings.mode !== 'full') return;
    
    try {
      setIsCancelled(false);
      setAutomationStatus('detecting');
      setAutomationStatusMessage('New message detected, preparing response...');
      
      // Get thread from ID
      const thread = threads.find(t => t.id === threadId);
      if (!thread) return;
      
      // Get all messages for context
      const allMessages = thread.messages.map(msg => ({
        role: msg.sender === 'You' ? 'user' : 'assistant',
        content: msg.message
      }));
      
      const styleGuide = {
        'formal': 'Use professional language and complete sentences.',
        'casual': 'Use casual SMS language and common text abbreviations (like u for you, r for are, tmrw for tomorrow, etc).',
        'very-casual': 'Use very casual texting style with lots of abbreviations and emojis.'
      };
      
      const lengthGuide = {
        'short': 'Keep responses very brief, ideally under 50 characters.',
        'medium': 'Keep responses concise, around 100-150 characters.',
        'long': 'Provide detailed responses when appropriate.'
      };
      
      const context = [
        {
          role: 'system',
          content: hasPhone(thread) 
            ? `You are an AI assistant automatically responding to SMS messages. ${styleGuide[threadSettings.responseStyle as keyof typeof styleGuide]} ${lengthGuide[threadSettings.messageLength as keyof typeof lengthGuide]} Keep messages natural and contextually appropriate. Do not use quotation marks.`
            : 'You are an AI assistant generating a response suggestion. Keep the tone professional but friendly. Focus on being clear and helpful. Do not use quotation marks.'
        },
        ...allMessages
      ];
      
      // Add delay if specified
      const delay = getDelayDuration(threadSettings.responseDelay);
      if (delay > 0 && !isCancelled) {
        await new Promise(resolve => setTimeout(resolve, delay));
      }
      
      if (isCancelled) {
        throw new Error('Automatic response cancelled');
      }

      // Show thinking status
      setAutomationStatus('thinking');
      setAutomationStatusMessage('AI is generating a response...');
      
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          message: 'Please generate an automatic response to the latest message.',
          context: context
        })
      });

      if (!response.ok) {
        throw new Error('Failed to generate automatic response');
      }

      const data = await response.json();
      const cleanResponse = data.response.replace(/['"]/g, '');
      
      // Send the message directly using the SMS API
      if (hasPhone(thread)) {
        const response = await fetch('/api/sms/send', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            to: thread.phone,
            message: cleanResponse,
            threadId: thread.id,
            useEnvVars: true,
            from: thread.destinationNumber
          })
        });

        if (!response.ok) {
          throw new Error('Failed to send SMS');
        }

        // Update the thread with the sent message
        const newMessage = {
          sender: 'You',
          message: cleanResponse,
          timestamp: new Date().toISOString()
        };

        setThreads(prev => {
          const updatedThreads = prev.map(t => {
            if (t.id === thread.id) {
              return {
                ...t,
                messages: [...t.messages, newMessage]
              };
            }
            return t;
          });
          localStorage.setItem('threads', JSON.stringify(updatedThreads));
          return updatedThreads;
        });
      }
      
    } catch (error: any) {
      console.error('Error in automatic response:', error);
      if (error.message !== 'Automatic response cancelled') {
        toast({
          title: "Automatic Response Error",
          description: error.message || "Failed to generate automatic response",
          variant: "destructive",
        });
      }
    }
  }, [threads, toast, isCancelled]);

  // Add polling mechanism for SMS history
  useEffect(() => {
    if (!user) return;
    
    // Create a debounced version of fetchSMSHistory for polling
    const debouncedFetchSMSHistory = debounce(async () => {
      if (user && !isLoadingSMSHistory) {
        const previousThreads = [...threads];
        await fetchSMSHistory();
        
        // Check for new threads
        const newThreads = threads.filter(thread => 
          !previousThreads.some(prevThread => prevThread.id === thread.id)
        );
        
        // Apply default automation settings to new threads
        if (newThreads.length > 0) {
          setThreads(prev => {
            const updatedThreads = prev.map(thread => {
              if (newThreads.some(newThread => newThread.id === thread.id)) {
                // Save automation settings to localStorage for this thread
                localStorage.setItem(`thread_${thread.id}_automation`, JSON.stringify({
                  isEnabled: defaultAutomationSettings.isEnabled,
                  mode: defaultAutomationSettings.mode,
                  responseDelay: defaultAutomationSettings.responseDelay,
                  responseStyle: defaultAutomationSettings.responseStyle,
                  messageLength: defaultAutomationSettings.messageLength
                }));
                
                return {
                  ...thread,
                  automationSettings: {
                    isEnabled: defaultAutomationSettings.isEnabled,
                    mode: defaultAutomationSettings.mode,
                    responseDelay: defaultAutomationSettings.responseDelay,
                    responseStyle: defaultAutomationSettings.responseStyle,
                    messageLength: defaultAutomationSettings.messageLength
                  }
                };
              }
              return thread;
            });
            return updatedThreads;
          });
        }
      }
    }, 500);
    
    // Set up polling for all SMS history every 30 seconds
    const intervalId = setInterval(() => {
      debouncedFetchSMSHistory();
    }, 30000);
    
    // Initial fetch
    debouncedFetchSMSHistory();
    
    return () => {
      clearInterval(intervalId);
    };
  }, [user, fetchSMSHistory, isLoadingSMSHistory, threads]);

  // Add function to get thread-specific automation settings
  const getThreadAutomationSettings = useCallback((threadId: string) => {
    const savedSettings = localStorage.getItem(`thread_${threadId}_automation`);
    if (savedSettings) {
      return JSON.parse(savedSettings);
    }
    return defaultAutomationSettings;
  }, [defaultAutomationSettings]);

  // Add polling for the selected SMS contact
  useEffect(() => {
    if (!user || !('isSMS' in selectedUser) || !selectedUser.isSMS || !('phone' in selectedUser)) return;
    
    // Create a debounced version of fetchSMSHistory for the selected contact
    const debouncedFetchContactSMSHistory = debounce(async () => {
      if (!isLoadingSMSHistory && 'phone' in selectedUser) {
        const previousMessages = [...selectedUser.messages]; // Create a copy of current messages
        await fetchSMSHistory(selectedUser.phone);
        
        // Check if we received any new messages
        const newMessages = selectedUser.messages.filter(msg => {
          return !previousMessages.some(prevMsg => 
            prevMsg.timestamp === msg.timestamp && 
            prevMsg.message === msg.message &&
            prevMsg.sender === msg.sender
          );
        });

        // Process each new message
        for (const newMessage of newMessages) {
          // Only respond to messages from the contact (not our own messages)
          if (newMessage.sender !== 'You') {
            if (isAutomationEnabled && automationMode === 'full') {
              // In full auto mode, generate and send response automatically
              handleAutomaticResponse(newMessage, selectedUser.id);
            } else if (isAutomationEnabled && automationMode === 'semi') {
              // In semi-auto mode, generate suggestion and populate input
              setIsGeneratingSuggestion(true);
              try {
                const allMessages = selectedUser.messages.map(msg => ({
                  role: msg.sender === 'You' ? 'user' : 'assistant',
                  content: msg.message
                }));
                
                const response = await fetch('/api/chat', {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json'
                  },
                  body: JSON.stringify({
                    message: 'Please suggest a response to the conversation above.',
                    context: [
                      {
                        role: 'system',
                        content: hasPhone(selectedUser) 
                          ? `You are an AI assistant generating SMS response suggestions. Use ${responseStyle === 'formal' ? 'professional language and complete sentences' : responseStyle === 'casual' ? 'casual SMS language and common text abbreviations (like u for you, r for are, tmrw for tomorrow, etc)' : 'very casual texting style with lots of abbreviations and emojis'}. Keep responses ${messageLength === 'short' ? 'very brief, ideally under 50 characters' : messageLength === 'medium' ? 'concise, around 100-150 characters' : 'detailed when appropriate'}. Do not use quotation marks.`
                          : 'You are an AI assistant generating a response suggestion. Keep the tone professional but friendly. Focus on being clear and helpful. Do not use quotation marks.'
                      },
                      ...allMessages
                    ]
                  })
                });

                if (!response.ok) {
                  throw new Error('Failed to generate suggestion');
                }

                const data = await response.json();
                const cleanResponse = data.response.replace(/['"]/g, '');
                setAiSuggestion(cleanResponse);
                setInputMessage(cleanResponse);
              } catch (error: any) {
                console.error('Error generating suggestion:', error);
                toast({
                  title: "Error",
                  description: error.message || "Failed to generate suggestion",
                  variant: "destructive",
                });
              } finally {
                setIsGeneratingSuggestion(false);
              }
            }
          }
        }
      }
    }, 500);
    
    // Set up polling for new messages every 10 seconds
    const intervalId = setInterval(() => {
      debouncedFetchContactSMSHistory();
    }, 10000);
    
    // Initial fetch when component mounts or selected user changes
    debouncedFetchContactSMSHistory();
    
    return () => {
      clearInterval(intervalId);
    };
  }, [user, selectedUser, fetchSMSHistory, isLoadingSMSHistory, isAutomationEnabled, automationMode, handleAutomaticResponse, toast, responseStyle, messageLength]);

  // Add the deleteThread function
  const deleteThread = useCallback((threadId: string) => {
    setThreads(prev => {
      const updatedThreads = prev.filter(thread => thread.id !== threadId);
      localStorage.setItem('threads', JSON.stringify(updatedThreads));
      
      // If we're deleting the selected thread, select the first available thread
      if (selectedUser.id === threadId && updatedThreads.length > 0) {
        setSelectedUser(updatedThreads[0]);
        setMobileSelectedUser(updatedThreads[0]);
      }
      
      return updatedThreads;
    });
      
      toast({
      title: "Chat deleted",
      description: "The conversation has been removed",
    });
  }, [selectedUser.id, toast]);

  // Add the saveContactToSupabase function
  const saveContactToSupabase = async (contact: any) => {
    if (!user?.id) return;
    
    try {
      const { error } = await supabase
        .from('contacts')
        .insert([contact]);
        
      if (error) throw error;
      
      toast({
        title: "Contact saved",
        description: `${contact.first_name} ${contact.last_name} has been added to your contacts`
      });
    } catch (error) {
      console.error('Error saving contact to Supabase:', error);
      toast({
        title: "Error saving contact",
        description: "Failed to save contact to database",
        variant: "destructive"
      });
    }
  };

  // Update the createSMSContact function
  const createSMSContact = useCallback((fromNumber?: string) => {
    if (!newContactName.trim() || !newContactPhone.trim()) {
        toast({
          title: 'Error creating contact',
          description: 'Name and phone number are required',
          variant: 'destructive'
        });
        return;
    }

    try {
      console.log('Creating new SMS contact with name:', newContactName, 'and phone:', newContactPhone);
      
      // Check if there's already a thread for this phone number
      const existingThread = threads.find(thread => 
        hasPhone(thread) && 
        thread.phone === newContactPhone
      );
      
      if (existingThread) {
        console.log('Found existing thread for phone number:', {
          threadId: existingThread.id,
          phone: existingThread.phone
        });
        
        // Select the existing thread
        setSelectedUser(existingThread);
        setNewMessageModalOpen(false);
        
        toast({
          title: 'Conversation Opened',
          description: `Showing existing conversation with ${newContactName}`,
        });
        
        return;
      }
      
      // Build contact object
      const contactId = uuidv4();
      const newContact = {
        id: contactId,
        first_name: newContactName.split(' ')[0] || '',
        last_name: newContactName.split(' ').slice(1).join(' ') || '',
        phone: newContactPhone,
        user_id: user?.id || '',
      };
      
      // Add to SMS Contacts
      setSMSContacts(prev => [...prev, {
        id: contactId,
        name: newContactName,
        phone: newContactPhone
      }]);
      
      // Create a thread for this contact
      const newThread: SMSUser = {
        id: uuidv4(),
        profile: '/placeholders/avatar.png',
        username: newContactName,
        fullName: newContactName,
        title: `SMS with ${newContactName}`,
        messages: [],
        phone: newContact.phone,
        isSMS: true as const,
        destinationNumber: fromNumber || 'unknown' // Add destination number
      };
      
      setThreads(prev => [newThread, ...prev]);
      setSelectedUser(newThread);
      setNewMessageModalOpen(false);
      
      // Clear input fields
      setNewContactName('');
      setNewContactPhone('');
      
      // Save contact to Supabase
      saveContactToSupabase(newContact);
      
    } catch (error) {
      console.error('Error creating SMS contact:', error);
      toast({
        title: 'Error creating contact',
        description: 'Failed to create SMS contact',
        variant: 'destructive'
      });
    }
  }, [newContactName, newContactPhone, user?.id, threads, setSMSContacts, setThreads, setSelectedUser, setNewMessageModalOpen, toast]);

  // Function to toggle details panel
  const toggleDetailsPanel = useCallback((e?: React.MouseEvent<HTMLButtonElement>) => {
    if (e) {
      e.preventDefault();
      e.stopPropagation();
    }
    setShowDetailsPanel(prev => !prev);
  }, []);

  // Function to toggle mobile details panel
  const toggleMobileDetailsPanel = useCallback((e?: React.MouseEvent<HTMLButtonElement>) => {
    if (e) {
      e.preventDefault();
      e.stopPropagation();
    }
    setShowMobileDetailsPanel(prev => !prev);
  }, []);

  // Function to close mobile details panel
  const closeMobileDetailsPanel = useCallback((e?: React.MouseEvent<HTMLButtonElement>) => {
    if (e) {
      e.preventDefault();
      e.stopPropagation();
    }
    setShowMobileDetailsPanel(false);
  }, []);

  // Add a function to handle message click to show details
  const handleMessageClick = (message: Message, isReceived: boolean, event?: React.MouseEvent<HTMLDivElement>) => {
    // Prevent default behavior if event is provided
    if (event) {
      event.preventDefault();
      event.stopPropagation();
    }
    
    // For SMS messages, we need to determine the actual from/to numbers
    if ('isSMS' in selectedUser && selectedUser.isSMS) {
      const twilioNumber = selectedUser.destinationNumber || '';
      const contactNumber = selectedUser.phone || '';
      
      setSelectedMessage({
        from: isReceived ? contactNumber : twilioNumber,
        to: isReceived ? twilioNumber : contactNumber,
        body: message.message,
        dateSent: message.timestamp,
        direction: isReceived ? 'inbound' : 'outbound'
      });
    }
  };

  // Add state for rate limiting
  const [retryCount, setRetryCount] = useState(0);
  const [lastRequestTime, setLastRequestTime] = useState(0);
  const MIN_REQUEST_INTERVAL = 500; // Reduce to 500ms between requests
  const MAX_RETRIES = 5; // Increase max retries
  const INITIAL_RETRY_DELAY = 2000; // Start with 2 second delay
  const MAX_RETRY_DELAY = 15000; // Max 15 second delay

  // Update the generateAISuggestion function to correctly format the conversation context
  const generateAISuggestion = async () => {
    if (!selectedUser || selectedUser.messages.length === 0) return;

    try {
      setIsGeneratingSuggestion(true);
      
      // Format the conversation history in chronological order
      const recentMessages = selectedUser.messages.slice(-10); // Get last 10 messages for context
      
      // Map messages to the format expected by OpenAI - explicitly define who's who
      const allMessages = recentMessages.map(msg => {
        const isUserMessage = msg.sender === 'You';
        return {
          role: isUserMessage ? 'user' : 'assistant', 
          content: msg.message,
          name: isUserMessage ? 'user' : 'contact'
        };
      });
      
      // Extract the topics being discussed for better context
      const conversationTopics = getConversationTopics(recentMessages);
      
      // Create a detailed system message with proper context
      const systemPrompt = `You are helping draft responses in a conversation between the user and ${selectedUser.fullName}.
This is a conversation about ${conversationTopics}.
Current conversation: The most recent messages are about ${getRecentMessageSummary(recentMessages)}.

Your task is to suggest a natural DIRECT response to the most recent message from ${selectedUser.fullName}.
- Write as if you ARE the user responding directly (first person perspective)
- Stay focused on the current topic of conversation (${conversationTopics})
- Do not introduce new topics unless the conversation has come to a natural end
- Never say "Hello" or introduce yourself - this is an ongoing conversation
- Respond directly to what was just said
- Keep your response conversational and natural
`;

      // Prepare the context with proper system message
      const context = [
        { role: 'system', content: systemPrompt },
        ...allMessages
      ];
      
      // Add a specific user prompt to guide response generation
      context.push({
        role: 'user', 
        content: `Based on this conversation history, write a direct response that I would give to "${recentMessages[recentMessages.length-1].message}". Make sure it sounds natural and directly continues our Spider-Man movie discussion.`
      });
      
      console.log('Sending AI request with context:', {
        messageCount: allMessages.length,
        lastMessage: recentMessages[recentMessages.length-1].message,
        systemPromptLength: systemPrompt.length
      });
      
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          message: 'Suggest a response for this conversation',
          context: context
        })
      });

      if (!response.ok) {
        throw new Error('Failed to generate suggestion');
      }

      const data = await response.json();
      const cleanResponse = data.response.replace(/['"]/g, '');
      setAiSuggestion(cleanResponse);
    } catch (error: any) {
      console.error('Error generating suggestion:', error);
      toast({
        title: "Error",
        description: "Failed to generate message suggestion",
        variant: "destructive",
      });
    } finally {
      setIsGeneratingSuggestion(false);
    }
  };

  // Helper functions for improved context
  const getConversationTopics = (messages: Message[]): string => {
    if (messages.length === 0) return "general topics";
    
    // Extract unique words that might indicate topics
    const text = messages.map(msg => msg.message).join(' ');
    const words = text.toLowerCase().split(/\W+/);
    
    // Count occurrences of potential topic words (ignore common words)
    const commonWords = new Set(['the', 'and', 'or', 'but', 'if', 'a', 'an', 'to', 'in', 'of', 'for', 'was', 'is', 'are', 'be', 'that', 'this', 'it', 'you', 'i', 'me', 'my', 'mine', 'your', 'yours', 'he', 'she', 'they', 'their', 'them', 'his', 'her', 'hers', 'its', 'have', 'has', 'had', 'do', 'did', 'done']);
    const wordCounts: Record<string, number> = {};
    
    words.forEach(word => {
      if (word.length > 3 && !commonWords.has(word)) {
        wordCounts[word] = (wordCounts[word] || 0) + 1;
      }
    });
    
    // Get top 5 frequent words
    const topWords = Object.entries(wordCounts)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(([word]) => word);
    
    if (topWords.length > 0) {
      return topWords.join(', ');
    }
    
    // Fallback - check for specific keywords
    if (text.toLowerCase().includes('spider') || text.toLowerCase().includes('marvel')) {
      return "Spider-Man movies and Marvel";
    }
    
    return "the current conversation";
  };

  const getRecentMessageSummary = (messages: Message[]): string => {
    if (messages.length === 0) return "no recent messages";
    
    // Get the most recent message
    const lastMessage = messages[messages.length - 1];
    
    // Return a truncated version of the last message
    return lastMessage.message.length > 70 
      ? lastMessage.message.substring(0, 70) + '...'
      : lastMessage.message;
  };

  // Add effect to persist automation settings
  useEffect(() => {
    localStorage.setItem('automationMode', automationMode);
    localStorage.setItem('isAutomationEnabled', isAutomationEnabled.toString());
    localStorage.setItem('responseDelay', responseDelay);
    localStorage.setItem('responseStyle', responseStyle);
    localStorage.setItem('messageLength', messageLength);
  }, [automationMode, isAutomationEnabled, responseDelay, responseStyle, messageLength]);

  // Add effect to generate instant response when automation is enabled
  useEffect(() => {
    if (isAutomationEnabled && selectedUser.messages.length > 0) {
      const lastMessage = selectedUser.messages[selectedUser.messages.length - 1];
      // Only generate response if the last message is from the contact
      if (lastMessage.sender !== 'You') {
        if (automationMode === 'full') {
          handleAutomaticResponse(lastMessage, selectedUser.id);
        } else {
          // For semi-auto mode, generate suggestion
          const generateSuggestion = async () => {
            setIsGeneratingSuggestion(true);
            try {
              const allMessages = selectedUser.messages.map(msg => ({
                role: msg.sender === 'You' ? 'user' : 'assistant',
                content: msg.message
              }));
              
              const response = await fetch('/api/chat', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  message: 'Please suggest a response to the conversation above.',
                  context: [
                    {
                      role: 'system',
                      content: hasPhone(selectedUser) 
                        ? `You are an AI assistant generating SMS response suggestions. Use ${responseStyle === 'formal' ? 'professional language and complete sentences' : responseStyle === 'casual' ? 'casual SMS language and common text abbreviations (like u for you, r for are, tmrw for tomorrow, etc)' : 'very casual texting style with lots of abbreviations and emojis'}. Keep responses ${messageLength === 'short' ? 'very brief, ideally under 50 characters' : messageLength === 'medium' ? 'concise, around 100-150 characters' : 'detailed when appropriate'}. Do not use quotation marks.`
                        : 'You are an AI assistant generating a response suggestion. Keep the tone professional but friendly. Focus on being clear and helpful. Do not use quotation marks.'
                    },
                    ...allMessages
                  ]
                })
              });

              if (!response.ok) {
                throw new Error('Failed to generate suggestion');
              }

              const data = await response.json();
              const cleanResponse = data.response.replace(/['"]/g, '');
              setAiSuggestion(cleanResponse);
              setInputMessage(cleanResponse);
            } catch (error: any) {
              console.error('Error generating suggestion:', error);
              toast({
                title: "Error",
                description: error.message || "Failed to generate suggestion",
                variant: "destructive",
              });
            } finally {
              setIsGeneratingSuggestion(false);
            }
          };
          generateSuggestion();
        }
      }
    }
  }, [isAutomationEnabled, selectedUser.id]);

  // Update the automation mode setter to handle instant response
  const handleAutomationModeChange = async (newMode: 'semi' | 'full') => {
    setAutomationMode(newMode);
    if (isAutomationEnabled && selectedUser.messages.length > 0) {
      const lastMessage = selectedUser.messages[selectedUser.messages.length - 1];
      if (lastMessage.sender !== 'You') {
        if (newMode === 'full') {
          // For full auto mode, generate and send response automatically
          setAutomationStatus('detecting');
          setAutomationStatusMessage('New message detected, preparing response...');
          
          const allMessages = selectedUser.messages.map(msg => ({
            role: msg.sender === 'You' ? 'user' : 'assistant',
            content: msg.message
          }));
          
          const styleGuide = {
            'formal': 'Use professional language and complete sentences.',
            'casual': 'Use casual SMS language and common text abbreviations (like u for you, r for are, tmrw for tomorrow, etc).',
            'very-casual': 'Use very casual texting style with lots of abbreviations and emojis.'
          };
          
          const lengthGuide = {
            'short': 'Keep responses very brief, ideally under 50 characters.',
            'medium': 'Keep responses concise, around 100-150 characters.',
            'long': 'Provide detailed responses when appropriate.'
          };
          
          const context = [
            {
              role: 'system',
              content: hasPhone(selectedUser) 
                ? `You are an AI assistant automatically responding to SMS messages. ${styleGuide[responseStyle]} ${lengthGuide[messageLength]} Keep messages natural and contextually appropriate. Do not use quotation marks.`
                : 'You are an AI assistant generating a response suggestion. Keep the tone professional but friendly. Focus on being clear and helpful. Do not use quotation marks.'
            },
            ...allMessages
          ];
          
          try {
            // Add delay if specified
            const delay = getDelayDuration(responseDelay);
            if (delay > 0) {
              setAutomationStatusMessage(`Waiting ${delay/1000}s before responding...`);
              await new Promise(resolve => setTimeout(resolve, delay));
            }
            
            // Show thinking status
            setAutomationStatus('thinking');
            setAutomationStatusMessage('AI is generating a response...');
            
            const response = await fetch('/api/chat', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                message: 'Please generate an automatic response to the latest message.',
                context: context
              })
            });

            if (!response.ok) {
              throw new Error('Failed to generate automatic response');
            }

            const data = await response.json();
            const cleanResponse = data.response.replace(/['"]/g, '');
            
            // Show sending status
            setAutomationStatus('sending');
            setAutomationStatusMessage('Sending automatic response...');
            
            // Automatically send the response
            const fakeEvent = { preventDefault: () => {} } as React.FormEvent;
            setInputMessage(cleanResponse);
            await sendMessage(fakeEvent);
            
            // Reset status after successful send
            setAutomationStatus('idle');
            setAutomationStatusMessage('');
            
          } catch (error: any) {
            console.error('Error in automatic response:', error);
            toast({
              title: "Error",
              description: error.message || "Failed to generate and send automatic response",
              variant: "destructive",
            });
            setAutomationStatus('idle');
            setAutomationStatusMessage('');
          }
        } else {
          // For semi-auto mode, just generate suggestion
          generateAISuggestion();
        }
      }
    }
  };

  // Update the automation toggle handler
  const handleAutomationToggle = async (enabled: boolean) => {
    setIsAutomationEnabled(enabled);
    if (enabled && selectedUser.messages.length > 0) {
      const lastMessage = selectedUser.messages[selectedUser.messages.length - 1];
      if (lastMessage.sender !== 'You') {
        if (automationMode === 'full') {
          // For full auto mode, generate and send response automatically
          setAutomationStatus('detecting');
          setAutomationStatusMessage('New message detected, preparing response...');
          
          const allMessages = selectedUser.messages.map(msg => ({
            role: msg.sender === 'You' ? 'user' : 'assistant',
            content: msg.message
          }));
          
          const styleGuide = {
            'formal': 'Use professional language and complete sentences.',
            'casual': 'Use casual SMS language and common text abbreviations (like u for you, r for are, tmrw for tomorrow, etc).',
            'very-casual': 'Use very casual texting style with lots of abbreviations and emojis.'
          };
          
          const lengthGuide = {
            'short': 'Keep responses very brief, ideally under 50 characters.',
            'medium': 'Keep responses concise, around 100-150 characters.',
            'long': 'Provide detailed responses when appropriate.'
          };
          
          const context = [
            {
              role: 'system',
              content: hasPhone(selectedUser) 
                ? `You are an AI assistant automatically responding to SMS messages. ${styleGuide[responseStyle]} ${lengthGuide[messageLength]} Keep messages natural and contextually appropriate. Do not use quotation marks.`
                : 'You are an AI assistant generating a response suggestion. Keep the tone professional but friendly. Focus on being clear and helpful. Do not use quotation marks.'
            },
            ...allMessages
          ];
          
          try {
            // Add delay if specified
            const delay = getDelayDuration(responseDelay);
            if (delay > 0) {
              setAutomationStatusMessage(`Waiting ${delay/1000}s before responding...`);
              await new Promise(resolve => setTimeout(resolve, delay));
            }
            
            // Show thinking status
            setAutomationStatus('thinking');
            setAutomationStatusMessage('AI is generating a response...');
            
            const response = await fetch('/api/chat', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                message: 'Please generate an automatic response to the latest message.',
                context: context
              })
            });

            if (!response.ok) {
              throw new Error('Failed to generate automatic response');
            }

            const data = await response.json();
            const cleanResponse = data.response.replace(/['"]/g, '');
            
            // Show sending status
            setAutomationStatus('sending');
            setAutomationStatusMessage('Sending automatic response...');
            
            // Automatically send the response
            const fakeEvent = { preventDefault: () => {} } as React.FormEvent;
            setInputMessage(cleanResponse);
            await sendMessage(fakeEvent);
            
            // Reset status after successful send
            setAutomationStatus('idle');
            setAutomationStatusMessage('');
            
          } catch (error: any) {
            console.error('Error in automatic response:', error);
            toast({
              title: "Error",
              description: error.message || "Failed to generate and send automatic response",
              variant: "destructive",
            });
            setAutomationStatus('idle');
            setAutomationStatusMessage('');
          }
        } else {
          // For semi-auto mode, just generate suggestion
          generateAISuggestion();
        }
      }
    }
  };

  // Add function to handle cancellation
  const handleCancelAutomation = useCallback(() => {
    setIsCancelled(true);
    setAutomationStatus('idle');
    setAutomationStatusMessage('');
    setCountdownSeconds(null);
    if (countdownRef.current) {
      clearInterval(countdownRef.current);
    }
  }, []);

  // Add service worker registration
  useEffect(() => {
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js').then(registration => {
          console.log('ServiceWorker registration successful');
        }).catch(err => {
          console.log('ServiceWorker registration failed:', err);
        });
      });
    }
  }, []);

  // Add this function before the return statement
  const handleSaveContact = async () => {
    if (!editedContact || !user) return;
    
    try {
      const { error } = await supabase
        .from('contacts')
        .update({
          first_name: editedContact.first_name,
          last_name: editedContact.last_name,
          phone: editedContact.phone,
          notes: editedContact.notes,
          vertical: editedContact.vertical,
          sub_category: editedContact.sub_category,
          preferred_language: editedContact.preferred_language
        })
        .eq('id', editedContact.id)
        .eq('user_id', user.id);

      if (error) throw error;

      // Update the threads with the new contact info
      setThreads(prev => 
        prev.map(thread => {
          if ('isSMS' in thread && thread.isSMS && thread.phone === editedContact.phone) {
            const fullName = `${editedContact.first_name || ''} ${editedContact.last_name || ''}`.trim();
            return {
              ...thread,
              fullName,
              username: fullName.split(' ')[0]
            };
          }
          return thread;
        })
      );

      // Update selected user if it's the current contact
      if ('isSMS' in selectedUser && selectedUser.isSMS && selectedUser.phone === editedContact.phone) {
        const fullName = `${editedContact.first_name || ''} ${editedContact.last_name || ''}`.trim();
        setSelectedUser(prev => ({
          ...prev,
          fullName,
          username: fullName.split(' ')[0]
        }));
      }

      setIsEditingContact(false);
      toast({
        title: "Success",
        description: "Contact information updated successfully",
      });
    } catch (error) {
      console.error('Error updating contact:', error);
      toast({
        title: "Error",
        description: "Failed to update contact information",
        variant: "destructive",
      });
    }
  };

  // Add state for Supabase subscription
  const [supabaseSubscription, setSupabaseSubscription] = useState<RealtimeChannel | null>(null);

  // Add useEffect for real-time SMS updates
  useEffect(() => {
    if (!user) return;

    // Subscribe to the twilio_messages table for real-time updates
    const channel = supabase
      .channel('sms-updates')
      .on(
        'postgres_changes',
        {
          event: 'INSERT',
          schema: 'public',
          table: 'twilio_messages',
          filter: `user_id=eq.${user.id}`
        },
        async (payload) => {
          console.log('New SMS received:', payload);
          const { new: newMessage } = payload;

          // Format the message
          const formattedMessage = {
            sender: newMessage.direction === 'inbound' ? newMessage.from_phone : 'You',
            message: newMessage.body,
            timestamp: newMessage.date_created,
            source: 'supabase' as const,
            direction: newMessage.direction as 'inbound' | 'outbound',
            to: newMessage.to_phone,
            from: newMessage.from_phone
          };

          // Find the relevant thread
          const threadPhone = newMessage.direction === 'inbound' ? newMessage.from_phone : newMessage.to_phone;
          
          // Update threads with the new message
          setThreads(prevThreads => {
            return prevThreads.map(thread => {
              if ('isSMS' in thread && thread.isSMS && normalizePhoneNumber(thread.phone) === normalizePhoneNumber(threadPhone)) {
                // Update the thread with the new message
                return {
                  ...thread,
                  messages: [...thread.messages, formattedMessage]
                };
              }
              return thread;
            });
          });

          // If this is an incoming message and automation is enabled, handle it
          if (newMessage.direction === 'inbound' && isAutomationEnabled) {
            const thread = threads.find(t => 
              'isSMS' in t && t.isSMS && 
              normalizePhoneNumber(t.phone) === normalizePhoneNumber(threadPhone)
            );
            
            if (thread) {
              if (automationMode === 'full') {
                handleAutomaticResponse(formattedMessage, thread.id);
              } else if (automationMode === 'semi') {
                generateAISuggestion();
              }
            }
          }
        }
      )
      .subscribe();

    setSupabaseSubscription(channel);

    // Cleanup subscription on unmount
    return () => {
      if (supabaseSubscription) {
        supabase.removeChannel(supabaseSubscription);
      }
    };
  }, [user, supabase, threads, isAutomationEnabled, automationMode]);

  // Add state for new SMS dialog
  const [isNewSMSDialogOpen, setIsNewSMSDialogOpen] = useState(false);

  // Process search results
  useEffect(() => {
    if (debouncedSearch.trim() === '') return;
    
    // Your search processing logic
  }, [debouncedSearch]);

  // Function to create a new SMS conversation
  // Add the function to create a new SMS conversation
  const createNewSMSConversation = useCallback((phoneNumber: string, contactName: string, fromNumber: string) => {
    // Check if we already have a thread for this phone number
    const existingThreadIndex = threads.findIndex(thread => 
      hasPhone(thread) && thread.phone === phoneNumber
    );

    // Create a new SMS thread object
    const newThread: SMSUser = {
      id: uuidv4(),
      profile: '/placeholders/avatar.png',
      username: phoneNumber,
      fullName: contactName || phoneNumber,
      title: `SMS with ${contactName || phoneNumber}`,
      messages: [],
      phone: phoneNumber,
      isSMS: true,
      destinationNumber: fromNumber
    };

    if (existingThreadIndex !== -1) {
      // Select the existing thread
      setSelectedUser(threads[existingThreadIndex]);
    } else {
      // Add the new thread to the list and select it
      setThreads(prev => [newThread, ...prev]);
      setSelectedUser(newThread);
    }

    // Close the dialog
    setIsNewSMSDialogOpen(false);
  }, [threads, setThreads, setSelectedUser]);

  // First let's add state for storing the fromNumber
  const [newContactFromNumber, setNewContactFromNumber] = useState('');

  // Add a new type to track read status
  interface ReadStatusMap {
    [threadId: string]: {
      lastReadTimestamp: string;
    };
  }

  // In the ChatPage component, add a new state for read status
  const [readStatusMap, setReadStatusMap] = useState<ReadStatusMap>(() => {
    if (typeof window !== 'undefined') {
      const saved = localStorage.getItem('readStatus');
      return saved ? JSON.parse(saved) : {};
    }
    return {};
  });

  // Add a function to mark threads as read
  const markThreadAsRead = useCallback((threadId: string) => {
    if (!threadId) return;
    
    setReadStatusMap(prev => {
      const now = new Date().toISOString();
      const updated = {
        ...prev,
        [threadId]: {
          lastReadTimestamp: now
        }
      };
      localStorage.setItem('readStatus', JSON.stringify(updated));
      return updated;
    });
  }, []);

  // Helper function to check if thread has unread messages
  const hasUnreadMessages = useCallback((thread: ChatUser) => {
    if (!thread.messages.length) return false;
    
    const threadReadStatus = readStatusMap[thread.id];
    if (!threadReadStatus) return true; // Unread if never marked as read
    
    const lastMessageTime = new Date(thread.messages[thread.messages.length - 1].timestamp).getTime();
    const lastReadTime = new Date(threadReadStatus.lastReadTimestamp).getTime();
    
    return lastMessageTime > lastReadTime;
  }, [readStatusMap]);

  // Create an adapter function to match the interface expected by NewMessageModal
  const handleAddNewContact = (name: string, phone: string, fromNumber: string) => {
    setNewContactName(name);
    setNewContactPhone(phone);
    createSMSContact(fromNumber);
  };

  // Add typing indicator component
  const TypingIndicator = () => (
    <div className="flex items-center space-x-2 p-3 bg-muted rounded-lg max-w-[80%]">
      <div className="flex space-x-1">
        <div className="h-2 w-2 bg-muted-foreground/70 rounded-full animate-bounce" style={{ animationDelay: '0ms' }}></div>
        <div className="h-2 w-2 bg-muted-foreground/70 rounded-full animate-bounce" style={{ animationDelay: '150ms' }}></div>
        <div className="h-2 w-2 bg-muted-foreground/70 rounded-full animate-bounce" style={{ animationDelay: '300ms' }}></div>
      </div>
      <span className="text-xs text-muted-foreground">typing...</span>
    </div>
  );

  // Add state for typing indicator
  const [isTyping, setIsTyping] = useState(false);

  // Add typing indicator simulation for demo purposes
  useEffect(() => {
    // Show typing indicator when input is cleared/sent
    if (inputMessage.length === 0 && selectedUser && selectedUser.messages.length > 0) {
      // Only show typing indicator sometimes for demo purposes
      if (Math.random() > 0.5) {
        setIsTyping(true);
        
        // Clear typing indicator after a random time between 2-5 seconds
        const timeout = setTimeout(() => {
          setIsTyping(false);
        }, 2000 + Math.random() * 3000);
        
        return () => clearTimeout(timeout);
      }
    } else if (inputMessage.length > 0) {
      setIsTyping(false);
    }
  }, [inputMessage, selectedUser]);

  return (
    <div className="flex h-screen overflow-hidden dark:text-white">
      {/* Add a style to hide the global chat button */}
      <style jsx global>{`
        #chat-widget-container {
          display: none !important;
        }
      `}</style>
      
      {/* Mobile menu button - only visible on mobile */}
      <button
        className={cn(
          "fixed left-4 top-4 z-40 md:hidden rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100",
          mobileSelectedUser ? "block" : "hidden"
        )}
        onClick={handleBackButtonClick}
      >
        <IconArrowLeft className="h-6 w-6" />
        <span className="sr-only">Go back</span>
      </button>

      {/* Sidebar/Thread list */}
      <div 
        className={cn(
          "w-full md:w-80 border-r flex flex-col md:flex md:flex-col dark:border-gray-800 h-full",
          mobileSelectedUser ? "hidden md:flex" : "flex"
        )}
      >
        {/* Sidebar header */}
        <div className="border-b px-4 py-3 flex items-center justify-between h-16 shrink-0 dark:border-gray-800">
          <div className="flex items-center gap-2">
            <IconMessages className="h-5 w-5" />
            <h1 className="text-xl font-bold">Messages</h1>
          </div>
          <div className="flex items-center gap-1">
            <Button 
              variant="ghost" 
              size="icon" 
              className="rounded-full"
              onClick={() => setIsNewSMSDialogOpen(true)}
            >
              <IconMessagePlus className="h-5 w-5" />
              <span className="sr-only">New message</span>
            </Button>
            <Button 
              variant="ghost" 
              size="icon" 
              className="rounded-full"
              onClick={createNewThread}
            >
              <IconRobot className="h-5 w-5" />
              <span className="sr-only">New AI chat</span>
            </Button>
          </div>
        </div>

        {/* Search */}
        <div className="px-4 py-3 shrink-0">
          <div className="relative">
            <IconSearch className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
            <Input
              placeholder="Search conversations..."
              className="pl-9"
              value={search}
              onChange={handleSearchChange}
            />
          </div>
        </div>

        {/* Thread list */}
        <div className="flex-1 overflow-auto">
          <ScrollArea className="h-full">
            <div className="space-y-2 py-2 px-2">
              {filteredChatList.length === 0 ? (
                <div className="p-4 text-center text-sm text-muted-foreground">
                  {search.trim() ? "No conversations found" : "No conversations yet"}
                </div>
              ) : (
                filteredChatList.map((thread) => (
                  <SMSThreadItem 
                    key={thread.id}
                    thread={thread}
                    isSelected={selectedUser.id === thread.id}
                    onClick={(e) => handleSelectUser(thread, true, e)}
                  />
                ))
              )}
            </div>
          </ScrollArea>
        </div>
      </div>

      {/* Main chat area */}
      <div 
        className={cn(
          "flex flex-col flex-1 h-full overflow-hidden",
          (!mobileSelectedUser && !selectedUser) ? "hidden md:flex" : 
          (mobileSelectedUser || selectedUser) ? "flex" : "hidden"
        )}
      >
        {/* Chat header */}
        <ChatHeader 
          user={mobileSelectedUser || selectedUser}
          onBackClick={handleBackButtonClick}
          onDetailsClick={toggleDetailsPanel}
          showBackButton={!!mobileSelectedUser}
        />

        {/* Messages area */}
        <div className="flex-1 overflow-auto">
          <ScrollArea className="h-full p-4" ref={chatContainerRef}>
            <div className="space-y-6">
              {Object.keys(currentMessage).length === 0 ? (
                <div className="h-full flex items-center justify-center text-muted-foreground">
                  <div className="text-center">
                    <IconMessages className="h-12 w-12 mx-auto mb-2 opacity-20" />
                    <p>No messages yet</p>
                    <p className="text-sm">Send a message to start the conversation</p>
                  </div>
                </div>
              ) : (
                Object.entries(currentMessage).map(([date, messages]) => (
                  <div key={date} className="space-y-4">
                    <div className="sticky top-0 z-10 flex justify-center items-center my-4">
                      <div className="h-px bg-muted-foreground/20 w-1/4"></div>
                      <div className="bg-accent/50 px-4 py-1.5 text-xs rounded-full text-muted-foreground font-medium mx-2">
                        {date}
                      </div>
                      <div className="h-px bg-muted-foreground/20 w-1/4"></div>
                    </div>
                    <div className="space-y-1">
                      {messages.map((message, index) => {
                        const isCurrentUserMessage = message.sender === "You";
                        const isPreviousSameSender = index > 0 && messages[index - 1].sender === message.sender;
                        const isNextSameSender = index < messages.length - 1 && messages[index + 1].sender === message.sender;
                        
                        return (
                          <div 
                            key={`${message.timestamp}-${index}`} 
                            className={cn(
                              "flex gap-3 items-end",
                              isCurrentUserMessage ? "justify-end" : "justify-start",
                              isPreviousSameSender ? "mt-1" : "mt-4"
                            )}
                            onClick={(e: React.MouseEvent<HTMLDivElement>) => handleMessageClick(message, !isCurrentUserMessage, e)}
                          >
                            {/* Only show avatar if it's first message in a sequence or from the contact */}
                            {!isCurrentUserMessage && !isPreviousSameSender && (
                              <Avatar className="h-8 w-8 rounded-full">
                                <AvatarImage src={(mobileSelectedUser || selectedUser).profile} alt={(mobileSelectedUser || selectedUser).fullName} />
                                <AvatarFallback className={cn(
                                  'isSMS' in (mobileSelectedUser || selectedUser) ? "bg-green-100 dark:bg-green-900" : 
                                  'isAI' in (mobileSelectedUser || selectedUser) ? "bg-blue-100 dark:bg-blue-900" : 
                                  "bg-gray-100 dark:bg-gray-800"
                                )}>
                                  {(mobileSelectedUser || selectedUser).fullName.charAt(0)}
                                </AvatarFallback>
                              </Avatar>
                            )}
                            
                            {/* Empty avatar space to maintain alignment */}
                            {!isCurrentUserMessage && isPreviousSameSender && <div className="w-8 h-8" aria-hidden="true"></div>}
                            
                            <div className={cn(
                              "px-3 py-2 max-w-[80%] break-words text-sm",
                              isCurrentUserMessage 
                                ? "bg-primary text-primary-foreground rounded-t-lg rounded-l-lg" 
                                : "bg-muted rounded-t-lg rounded-r-lg",
                              !isPreviousSameSender && isCurrentUserMessage && "rounded-tr-lg",
                              !isPreviousSameSender && !isCurrentUserMessage && "rounded-tl-lg",
                              !isNextSameSender && isCurrentUserMessage && "rounded-br-lg",
                              !isNextSameSender && !isCurrentUserMessage && "rounded-bl-lg"
                            )}>
                              <p>{message.message}</p>
                              <div className="flex items-center justify-end gap-1 mt-1">
                                <p className="text-xs opacity-70">
                                  {dayjs(message.timestamp).format('h:mm A')}
                                </p>
                                {isCurrentUserMessage && (
                                  <span className="text-xs">
                                    {message.source === 'pending' ? (
                                      <div className="h-3 w-3 inline-block border-2 border-t-transparent border-gray-500 rounded-full animate-spin" />
                                    ) : message.source === 'error' ? (
                                      <IconX className="h-3 w-3 inline-block text-red-500" />
                                    ) : message.source === 'supabase' ? (
                                      <IconCheck className="h-3 w-3 inline-block text-green-500" />
                                    ) : (
                                      <IconChecks className="h-3 w-3 inline-block text-green-500" />
                                    )}
                                  </span>
                                )}
                              </div>
                            </div>
                            
                            {/* Only show avatar if it's first message in a sequence or from the user */}
                            {isCurrentUserMessage && !isPreviousSameSender && (
                              <Avatar className="h-8 w-8 rounded-full">
                                <AvatarImage src="/placeholders/user-avatar.png" alt="You" />
                                <AvatarFallback className="bg-primary text-primary-foreground">
                                  Y
                                </AvatarFallback>
                              </Avatar>
                            )}
                            
                            {/* Empty avatar space to maintain alignment */}
                            {isCurrentUserMessage && isPreviousSameSender && <div className="w-8 h-8" aria-hidden="true"></div>}
                          </div>
                        );
                      })}
                    </div>
                  </div>
                ))
              )}
              
              {/* Add typing indicator */}
              {isTyping && (
                <div className="flex gap-3 items-end mt-4">
                  <Avatar className="h-8 w-8 rounded-full">
                    <AvatarImage src={(mobileSelectedUser || selectedUser).profile} alt={(mobileSelectedUser || selectedUser).fullName} />
                    <AvatarFallback className={cn(
                      'isSMS' in (mobileSelectedUser || selectedUser) ? "bg-green-100 dark:bg-green-900" : 
                      'isAI' in (mobileSelectedUser || selectedUser) ? "bg-blue-100 dark:bg-blue-900" : 
                      "bg-gray-100 dark:bg-gray-800"
                    )}>
                      {(mobileSelectedUser || selectedUser).fullName.charAt(0)}
                    </AvatarFallback>
                  </Avatar>
                  <div className="bg-muted rounded-t-lg rounded-r-lg px-3 py-2">
                    <TypingIndicator />
                  </div>
                </div>
              )}
            </div>
          </ScrollArea>
        </div>

        {/* Message input area */}
        <div className="border-t p-4 dark:border-gray-800 shrink-0">
          {/* Quick response suggestions */}
          {hasPhone(selectedUser) && selectedUser.messages.length > 0 && (
            <div className="mb-3 flex flex-wrap gap-2 justify-center">
              <Button 
                variant="outline" 
                size="sm" 
                className="text-xs py-1 px-3 rounded-full bg-accent/30 hover:bg-accent/50"
                onClick={() => setInputMessage("Yes, that works for me")}
              >
                Yes, that works for me
              </Button>
              <Button 
                variant="outline" 
                size="sm" 
                className="text-xs py-1 px-3 rounded-full bg-accent/30 hover:bg-accent/50"
                onClick={() => setInputMessage("I'll get back to you soon")}
              >
                I'll get back to you soon
              </Button>
              <Button 
                variant="outline" 
                size="sm" 
                className="text-xs py-1 px-3 rounded-full bg-accent/30 hover:bg-accent/50"
                onClick={() => setInputMessage("Thanks for letting me know")}
              >
                Thanks for letting me know
              </Button>
            </div>
          )}
          
          <form onSubmit={sendMessage} className="flex items-end gap-2">
            <div className="relative flex-1">
              <Textarea
                placeholder={isGeneratingSuggestion ? "Generating suggestion..." : "Type your message..."}
                className="min-h-[80px] resize-none pr-12 py-3 rounded-lg"
                value={inputMessage}
                onChange={(e) => setInputMessage(e.target.value)}
                disabled={isLoading || isGeneratingSuggestion}
              />
              <div className="absolute right-3 bottom-3">
                <Button
                  type="button"
                  size="icon"
                  variant="ghost"
                  className="h-8 w-8 rounded-full"
                  onClick={generateAISuggestion}
                  disabled={isLoading || isGeneratingSuggestion}
                >
                  <IconRobot className="h-4 w-4" />
                  <span className="sr-only">Get AI suggestion</span>
                </Button>
              </div>
            </div>
            <Button 
              type="submit" 
              size="icon" 
              className="h-10 w-10 shrink-0 rounded-full"
              disabled={isLoading || !inputMessage.trim()}
            >
              {isLoading ? (
                <div className="h-5 w-5 animate-spin rounded-full border-2 border-current border-t-transparent" />
              ) : (
                <IconSend className="h-5 w-5" />
              )}
              <span className="sr-only">Send</span>
            </Button>
          </form>
        </div>
      </div>

      {/* Details panel - only shown on large screens */}
      {showDetailsPanel && (
        <div className="hidden md:flex w-80 border-l flex-col overflow-hidden dark:border-gray-800 h-full">
          <div className="border-b px-6 py-4 flex items-center justify-between shrink-0 dark:border-gray-800">
            <h3 className="font-semibold">Details</h3>
            <Button 
              variant="ghost" 
              size="icon" 
              className="rounded-full"
              onClick={toggleDetailsPanel}
            >
              <IconX className="h-4 w-4" />
              <span className="sr-only">Close details</span>
            </Button>
          </div>
          <div className="flex-1 overflow-auto">
            <ScrollArea className="h-full">
              <div className="space-y-6 p-6">
                {/* Contact Info */}
                <div className="space-y-4">
                  <div className="text-center">
                    <Avatar className="h-20 w-20 mx-auto mb-3">
                      <AvatarImage src={selectedUser.profile} alt={selectedUser.fullName} />
                      <AvatarFallback className={cn(
                        'isSMS' in selectedUser ? "bg-green-100 dark:bg-green-900" : 
                        'isAI' in selectedUser ? "bg-blue-100 dark:bg-blue-900" : 
                        "bg-gray-100 dark:bg-gray-800"
                      )}>
                        {selectedUser.fullName.charAt(0)}
                      </AvatarFallback>
                    </Avatar>
                    <h4 className="font-semibold text-lg">{selectedUser.fullName}</h4>
                    <p className="text-sm text-muted-foreground">{selectedUser.title}</p>
                  </div>

                  {'isSMS' in selectedUser && selectedUser.isSMS && hasPhone(selectedUser) && (
                    <div className="space-y-2 pt-3">
                      <div className="flex items-center justify-between">
                        <h5 className="text-sm font-medium">Phone Number</h5>
                      </div>
                      <p className="text-sm">{selectedUser.phone}</p>
                    </div>
                  )}

                  {'isSMS' in selectedUser && selectedUser.isSMS && (
                    <div className="space-y-2 pt-2">
                      <div className="flex items-center justify-between">
                        <h5 className="text-sm font-medium">Twilio Number</h5>
                      </div>
                      <p className="text-sm">{selectedUser.destinationNumber || "Unknown"}</p>
                    </div>
                  )}
                </div>

                {/* Automation Settings Section - for SMS only */}
                {'isSMS' in selectedUser && selectedUser.isSMS && (
                  <div className="space-y-4 pt-2">
                    <Separator />
                    <h4 className="font-semibold">Automation Settings</h4>

                    <div className="flex items-center justify-between">
                      <Label htmlFor="automation-toggle" className="text-sm">Enable Automation</Label>
                      <Switch 
                        id="automation-toggle" 
                        checked={isAutomationEnabled}
                        onCheckedChange={handleAutomationToggle}
                      />
                    </div>

                    {isAutomationEnabled && (
                      <>
                        <div className="space-y-2">
                          <Label htmlFor="automation-mode" className="text-sm">Mode</Label>
                          <div className="grid grid-cols-2 gap-2">
                            <Button 
                              variant={automationMode === 'semi' ? "default" : "outline"} 
                              size="sm"
                              className="w-full"
                              onClick={() => handleAutomationModeChange('semi')}
                            >
                              Semi-Auto
                            </Button>
                            <Button 
                              variant={automationMode === 'full' ? "default" : "outline"} 
                              size="sm"
                              className="w-full"
                              onClick={() => handleAutomationModeChange('full')}
                            >
                              Full Auto
                            </Button>
                          </div>
                        </div>

                        <div className="space-y-2">
                          <Label htmlFor="response-delay" className="text-sm">Response Delay</Label>
                          <div className="grid grid-cols-4 gap-2">
                            <Button 
                              variant={responseDelay === 'none' ? "default" : "outline"} 
                              size="sm"
                              className="w-full"
                              onClick={() => setResponseDelay('none')}
                            >
                              None
                            </Button>
                            <Button 
                              variant={responseDelay === 'short' ? "default" : "outline"} 
                              size="sm"
                              className="w-full"
                              onClick={() => setResponseDelay('short')}
                            >
                              Short
                            </Button>
                            <Button 
                              variant={responseDelay === 'medium' ? "default" : "outline"} 
                              size="sm"
                              className="w-full"
                              onClick={() => setResponseDelay('medium')}
                            >
                              Medium
                            </Button>
                            <Button 
                              variant={responseDelay === 'long' ? "default" : "outline"} 
                              size="sm"
                              className="w-full"
                              onClick={() => setResponseDelay('long')}
                            >
                              Long
                            </Button>
                          </div>
                        </div>

                        <div className="space-y-2">
                          <Label htmlFor="response-style" className="text-sm">Response Style</Label>
                          <div className="grid grid-cols-3 gap-2">
                            <Button 
                              variant={responseStyle === 'formal' ? "default" : "outline"} 
                              size="sm"
                              className="w-full"
                              onClick={() => setResponseStyle('formal')}
                            >
                              Formal
                            </Button>
                            <Button 
                              variant={responseStyle === 'casual' ? "default" : "outline"} 
                              size="sm"
                              className="w-full"
                              onClick={() => setResponseStyle('casual')}
                            >
                              Casual
                            </Button>
                            <Button 
                              variant={responseStyle === 'very-casual' ? "default" : "outline"} 
                              size="sm"
                              className="w-full"
                              onClick={() => setResponseStyle('very-casual')}
                            >
                              Very Casual
                            </Button>
                          </div>
                        </div>

                        <div className="space-y-2">
                          <Label htmlFor="message-length" className="text-sm">Message Length</Label>
                          <div className="grid grid-cols-3 gap-2">
                            <Button 
                              variant={messageLength === 'short' ? "default" : "outline"} 
                              size="sm"
                              className="w-full"
                              onClick={() => setMessageLength('short')}
                            >
                              Short
                            </Button>
                            <Button 
                              variant={messageLength === 'medium' ? "default" : "outline"} 
                              size="sm"
                              className="w-full"
                              onClick={() => setMessageLength('medium')}
                            >
                              Medium
                            </Button>
                            <Button 
                              variant={messageLength === 'long' ? "default" : "outline"} 
                              size="sm"
                              className="w-full"
                              onClick={() => setMessageLength('long')}
                            >
                              Long
                            </Button>
                          </div>
                        </div>
                      </>
                    )}
                  </div>
                )}
              </div>
            </ScrollArea>
          </div>
        </div>
      )}

      {/* Message details modal */}
      {selectedMessage && (
        <MessageDetailsModal 
          message={selectedMessage} 
          twilioNumbers={twilioCredentials?.twilioNumbers || []}
          onClose={() => setSelectedMessage(null)} 
        />
      )}

      {/* New SMS dialog */}
      <NewSMSDialog
        isOpen={isNewSMSDialogOpen}
        onClose={() => setIsNewSMSDialogOpen(false)}
        onStartConversation={createNewSMSConversation}
        userId={user?.id || ''}
      />

      {/* New message modal */}
      <NewMessageModal
        isOpen={newMessageModalOpen}
        onClose={() => setNewMessageModalOpen(false)}
        userId={user?.id || ''}
        onSelectContact={handleSelectExistingContact}
        onAddNewContact={handleAddNewContact}
      />

      {/* Twilio setup guide dialog */}
      <TwilioSetupGuide 
        isOpen={showTwilioSetupGuide}
        onClose={() => setShowTwilioSetupGuide(false)}
        errorType={twilioErrorType}
      />
    </div>
  );
} 